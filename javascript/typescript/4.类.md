### 介绍

传统的JavaScript程序使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员来讲就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从ECMAScript 2015，也就是ECMAScript 6开始，JavaScript程序员将能够使用基于类的面向对象的方式。 使用TypeScript，我们允许开发者现在就使用这些特性，并且编译后的JavaScript可以在所有主流浏览器和平台上运行，而不需要等到下个JavaScript版本。

### 类

下面看一个使用类的例子：

    class Greeter {
        greeting: string;
        constructor(message: string) {
            this.greeting = message;
        }
        greet() {
            return `Hello, ${this.message}`;
        }
    }

    let greeter = new Greeter('World');

如果你使用过C#或Java，你会对这种语法非常熟悉。 我们声明一个 Greeter类。这个类有3个成员：一个叫做greeting的属性，一个构造函数和一个greet方法。

你会注意到，我们在引用任何一个类成员的时候都用了this。 它表示我们访问的是类的成员。

最后一行，我们使用new构造了Greeter类的一个实例。 它会调用之前定义的构造函数，创建一个 Greeter类型的新对象，并执行构造函数初始化它。

### 继承

在TypeScript里，我们可以使用常用的面向对象模式。 当然，基于类的程序设计中最基本的模式是允许使用继承来扩展现有的类。

看下面的例子：

    class Animal {
        name: string;
        constructor(theName: string) { this.name = theName; }
        move(distanceInMeters: number = 0) {
            console.log(`$(this.name) moved ${distanceInMeters}m.`);
        }
    }

    class Snake extends Animal {
        constructor(name: string) { super(name); }
        move(distanceInMeters = 5) {
            console.log('Slithering...');
            super.move(distanceInMeters);
        }
    }

    class Horse extends Animal {
        constructor(name: string) { super(name); }
        move(distanceInMeters = 45) {
            console.log('Galloping...');
            super.move(distanceInMeters);
        }
    }

    let sam = new Snake('Sammy the python');
    let tom: Animal = new Horse('Tommy the Palomino');

    sam.move();
    tom.move(34);

这个例子展示了TypeScript中继承的一些特征，它们与其它语言类似。 我们使用 extends关键字来创建子类。你可以看到Horse和Snake类是基类Animal的子类，并且可以访问其属性和方法。

包含构造函数的派生类必须调用super()，它会执行基类的构造方法。

这个例子演示了如何在子类里可以重写父类的方法。 Snake类和Horse类都创建了move方法，它们重写了从Animal继承来的move方法，使得move方法根据不同的类而具有不同的功能。 注意，即使 tom被声明为Animal类型，但因为它的值是Horse，tom.move(34)会调用Horse里的重写方法：

    Slithering...
    Sammy the Python moved 5m.
    Galloping...
    Tommy the Palomino moved 34m.

## 公有，私有，受保护的修饰符

### 默认为public

类的成员默认是 public。也可以明确标记成员是 public。它对外是可见的。

    class Animal {
        public name: string;
        public constructor(theNama: string) { this.name = theName; }
        public move(distanceInMeters: number) {
             console.log(`${this.name} moved ${distanceInMeters}m.`);
        }
    }

### 理解private

用 private 标记的成员只能在当前类中访问。

    class Animal {
        private name: string;
        constructor(theName: string) { this.name = theName; }
    }

    new Animal('cat').name;

TypeScript 是结构性类型系统。当两种不同类型的所有成员的类型是兼容的，它们的类型就是兼容的。

比较带有 private 或 protected 成员的类型时，只有当两个类中包含相同的 private 成员且来自同一处声明，这两个类才兼容。protected 也使用这个规则。

    class Animal {
        private name: string;
        constructor(theName: string) { this.name = theName; }
    }

    class Rhino extends Animal {
        constructor() { super('Rhino'); }
    }

    class Employee {
        private name: string;
        constructor(theName: string) { this.name = theName; }
    }

    let animal = new Animal('Goat');
    let rhino = new Rhino();
    let employee = new Employee('Bob');

    animal = rhino;
    animal = employee;      // error

Animal 和 Rhino 共享了来自 Animal 私有成员定义 private name: string，因此它们兼容。

Employee 里定义的私有成员 name 不是 Animal 里定义的私有成员 name。

### 理解protected

用 protected 标记的成员在派生类中仍然可以访问。

    class Person {
        protected name: string;
        constructor(name: string) { this.name = name; }
    }

    class Employee extends Person {
        private department: string;

        constructor(name: string, department: string) {
            super(name);
            this.department = department;
        }

        public getElevatorPitch() {
            return `Hello, my name is ${this.name} and I work in ${this.department}.`;
        }
    }

    let howard = new Employee('Howard', 'Sales');
    console.log(howard.getElevatorPitch());
    console.log(howard.name);   // error

不能在 Person 类外使用 name，但仍可以在派生类 Employee 类的实例方法中访问。

构造函数也能标记为 protected。这意味着这个类不能在包含它的类外实例化，但能被继承。

    class Person {
        protected name: string;
        protected constructor(theName: string) { this.name = theName; }
    }

    // Employee can extend Person
    class Employee extends Person {
        private department: string;

        constructor(name: string, department: string) {
            super(name);
            this.department = department;
        }

        public getElevatorPitch() {
            return `Hello, my name is ${this.name} and I work in ${this.department}.`;
        }
    }

    let howard = new Employee('Howard', 'sales');
    let john = new Person('John');      // error: the person constructor is protected.