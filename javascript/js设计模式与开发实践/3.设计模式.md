## 单例模式

### 定义

保证一个类型仅有一个实例，并提供一个访问它的全局访问点。

### 实现

```js
var getSingle = (function() {
    var ret;
    return function (fn) {
        return ret || (ret = fn.apply(this, arguments));
    }
})();

var CeateDiv = function () {
    var div = document.CreateElement('div');
    div.innerHTML = 'div';
    document.body.appendChild(div);
    return div;
};
var createSingleDiv = getSingle(CreateDiv);
```

## 策略模式

### 定义

定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。

### 组成

策略模式至少包含两部分：

1. 策略类：封装了具体算法，负责具体的计算过程
2. 环境类 Context，Context 接受客户的请求，随后把请求委托给某一个策略类

### 实现

```js
var strategies = {
    S: salary => salary * 4,
    A: salary => salary * 3,
    B: salary => salary * 2
};
var calculateBonus = (level, salary) => strategies[level](salary);
```

## 代理模式

### 定义

为一个对象提供一个代用品或占位符，以便控制对它的访问。

### 组成

1. 虚拟代理
2. 缓存代理

### 实现

```js
var image = (function () {
    var img = document.createElement('img');
    
    document.body.appendChild(img);
    
    return {
        setSrc(src) {
            img.src = src;
        }
    }
})();

var proxyImage = (function () {
    var img = new Image;
    img.onload = function () {
        image.setSrc(this.src);
    };

    return {
        setSrc(src) {
            image.setSrc('loading.gif');
            img.src = src;
        }
    }
})();

proxyImage.setSrc('xxx.jpg');
```

## 迭代器模式

### 定义

提供一种方法顺序访问一个聚合对象中的各个元素，又不需要暴露该对象的内部表示。

### 实现

1. 内部迭代器

```js
var each = function (arr, callback) {
    for (let i = 0, len = arr.length; i < len; i++) {
        callback(arr[i], len, arr);
    }
}
```

2. 外部迭代器

```js
var Iterator = function( obj ){
    var current = 0;
    
    var next = function(){
        current += 1;
    };
    
    var isDone = function(){
        return current >= obj.length;
    };
    
    var getCurrItem = function(){
        return obj[ current ];
    };
    
    return {
        next: next,
        isDone: isDone,
        getCurrItem: getCurrItem
    }
};
```

## 发布订阅模式

