## explain()
### queryPlanner
- namespace: 查询的表
- indexFilterSet: 是否有indexfilter
- winningPlan: 查询优化器针对该 query 所返回的最优执行计划的详细内容
    - stage: 最优执行计划的 **stage**
    - inputStage: 用来描述子 stage，并且为其父 stage 提供文档和索引关键字
    - direction: 查询顺序
### executionStats
- nReturned: 查询返回的条目
- totalKeysExamined: 索引扫描条目
- totalDocsExamined: 文档扫描条目
- executionTimeMillis: 整体查询时间
- executionStages
    - executionTimeMillisEstimate: 该查询根据 index 去检索 document 获得2001条数据的时间。
## 字段分析
### stage
值                  |            说明
-----               |-----
COLLSCAN            |           全表扫描
IXSCAN              |           索引扫描
FETCH               |           根据索引去检索指定 document
SHARD_MERGE         |           将各个分片返回数据进行 merge
SORT                |           表明在内存中进行了排序
LIMIT               |           使用 limit 限制返回数
SKIP                |           使用 skip 进行跳过
IDHACK              |           针对_id进行查询
SHARDING_FILTER     |           通过 mongos 对分片数据进行查询
COUNT               |           利用 db.coll.explain().count() 之类进行 count 运算
COUNTSCAN           |           count 不使用 Index 进行 count 时的 stage 返回
COUNT_SCAN          |           count 使用了 Index 进行 count 时的stage 返回
SUBPLA              |           未使用到索引的 $or 查询的 stage 返回
TEXT                |           使用全文索引进行查询时候的 stage 返回
PROJECTION          |           限定返回字段时候 stage 的返回
### 好的组合
对于普通查询，我希望看到stage的组合(查询的时候尽可能用上索引)：

Fetch+IDHACK

Fetch+ixscan

Limit+（Fetch+ixscan）

PROJECTION+ixscan

SHARDING_FITER+ixscan

COUNT_SCAN
### 差的组合
不希望看到包含如下的stage：

COLLSCAN(全表扫描)

SORT(使用sort但是无index)

不合理的SKIP

SUBPLA(未用到index的$or)

COUNTSCAN(不使用index进行count)