可以处理正则表达式的方法有：

    regexp.exec
    regexp.test
    string.match
    string.replace
    string.search
    string.split

## 一个例子

一个匹配数字的正则表达式：

    var parse_number = /^-?\d+(?:\.\d*)?(?:e[+\-]?\d+)?$/i;

我们用 /^  $/i 来框定了这个正则表达式。如果我们省略了这些标识，只要一个字符串包含一个数字，这个正则表达式就会进行匹配。

如果仅包含 ^，它将匹配一个以数字开头的字符串。

如果仅包含  $，它将匹配一个以数字结尾的字符串。

## 结构

创建正则表达式的方法：

- 字面量
- RegExp 构造器函数

RegExp 对象的属性

| 属性         | 用法                      |
|------------|-------------------------|
| global     | 标识 g 被使用，true           |
| ignoreCase | 标识 i 被使用，true           |
| multiline  | 标识 m 被使用，true           |
| lastIndex  | 下一次 exec 匹配开始的索引。初始值为 0 |
| source     | 正则表达式源码文本               |

## 元素

### 正则表达式分支

一个正则表达式分支包含一个或多个正则表达式序列，用 | 分隔。如果这些序列中的任意一项符合匹配条件，那么这个选择就被匹配。

### 正则表达式序列

一个正则表达式序列包含一个或多个正则表达式因子。

每个因子都能选择是否跟随一个量词。

### 正则表达式因子

一个因子可以是一个字符、一个由圆括号包围的组、一个字符类、或者是一个转义序列。

除了控制字符和特殊字符外，所有字符都会按字面匹配：

    \ / [ ] ( ) { } ? + * | . ^ $

### 正则表达式转义
|     |                                                                      |
|-----|----------------------------------------------------------------------|
| \d  | 等同于 [0-9]，匹配一个数字。                                                    |
| \s  | 等同于 [\f\n\r\t\u000B\u0020\u00A0\u2028\u2029]，这是 Unicode 空白符的一个不完全子集。 |
| \w  | 等同于 [0-9A-Za-z]。                                                     |
| \b  | 被指定一个字边界标识。                                                          |
| \1  | 指向分组 1 所捕获的文本的一个引用                                                   |
| \2  | 指向分组 2 所捕获的文本的引用，以此类推                                                |

### 正则表达式分组

**捕获型**：一个捕获型分组是一个被包围在圆括号中的正则表达式分支。

**非捕获型**：非捕获型分组被 (?: ) 包围，仅作简单匹配，不会干扰捕获型分组的编号。有略微的性能优势。

**向前正向匹配**：向前正向匹配分组被 (?= ) 包围，

**向前负向匹配**：向前负向匹配分组被 (?! ) 包围，

### 正则表达式字符集

    [abcd] 等同于 (?:a|b|c|d)

### 正则表达式量词

正则表达式因子可以用一个正则表达式量词后缀决定这个因子应该被匹配的次数。

|     |       |
|-----|-------|
| ?   | {0,1} |
| *   | {0,}  |
| +   | {1,}  |
